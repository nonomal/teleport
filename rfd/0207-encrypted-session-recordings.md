---
authors: Alan Parra (alan.parra@goteleport.com), Erik Tate (erik.tate@goteleport.com) 
state: draft
---

# RFD 207 - Encrypted Session Recordings

## Required Approvers
* Engineering: @rosstimothy, @zmb3, @espadolini, @nklaassen
* Security: doyensec

## What

This document proposes an approach to encrypting session recording data before
writing to disk or any S3 compatible long term storage.

## Why

File recordings on a node can be easily tampered with by users with enough access.
This could even occur within the session being recorded if the host user has root
access.

## Details

This document should fulfill the following requirements:
- Ability to encrypt session recording data during intermediate disk writes and long term storage.
- Ability to provide an externally managed public key for encryption.
- At least one method of playing back encrypted session recordings.
- Ability to source key material from an HSM.
- An encryption algorithm suitable for this workload.

### Encryption Algorithm

This RFD assumes the usage of [age](https://github.com/FiloSottile/age), which was
chosen for its provenance, simplicity, and focus on strong cryptography defaults
without requiring customization. The formal spec can be found
[here](https://age-encryption.org/v1). Officially supported key algorithms are
limited to X25519 (recommended by the spec), Ed25519, and RSA. Support for other
algorithms would either have to be requested from the upstream or manually
implemented as a custom plugin.

### Config Changes

Enabling encrypted session recordings requires configuring one or both of an HSM
configuration or a list of public key recipients. All private key identities
associated with configured recipients will be able to decrypt the resulting files.
This configuration is possible either through file configuration or dynamically
though the `session_recording_config` resource.

```yaml
# teleport.yaml
version: v3
auth_service:
  session_recording_recipients:
  - recipient_type: age_x25519
    public_key: age18l5tzttm32yqvh9pw3dlwp8h4qlvqnx8a40hf7svyag8hnumlsus43gc0y
  session_recording_hsm:
    enabled: true
    pkcs11_config_dir: /etc/pkcs11

```

```yaml
# session_recording_config resource
kind: session_recording_config
version: v2
spec:
  hsm:
    enabled: true
    pkcs11_config_dir: /etc/pkcs11/
  recipients:
  - recipient_type: age_x25519
    public_key: age18l5tzttm32yqvh9pw3dlwp8h4qlvqnx8a40hf7svyag8hnumlsus43gc0y
```

### Proto Specification
```proto
message SessionRecordingConfigSpecV2 {
  // (existing fields omitted)

  // Encrypted file recipients for recorded sessions.
  // If non-empty then all session recordings are encrypted end-to-end
  // (filesystem to end storage).
  repeated EncryptedFileRecipient recipients = 3 [(gogoproto.jsontag) = "recipients"];
}

// Illustrative, in practice a string is used for config readability.
enum EncryptedFileRecipientType {
  ENCRYPTED_FILE_RECIPIENT_TYPE_UNSPECIFIED = 0;

  // Age X25519 recipient string. Either the recipient alone or concatenated with a wrapped
  // identity.
  // * https://github.com/C2SP/C2SP/blob/8991f70ddf8a11de3a68d5a081e7be27e59d87c8/age.md#the-x25519-recipient-type
  ENCRYPTED_FILE_RECIPIENT_TYPE_AGE_X25519 = 1;
  // Ed25519 public key marshaled as an ssh-ed25519 public key.
  ENCRYPTED_FILE_RECIPIENT_TYPE_SSH_ED25519 = 2;
  // RSA public key marshaled as an ssh-rsa public key.
  // RSA keys must have at least 2048 bits.
  ENCRYPTED_FILE_RECIPIENT_TYPE_SSH_RSA = 3;
  // Ed25519 public key marshaled in PKIX PEM form.
  ENCRYPTED_FILE_RECIPIENT_TYPE_ED25519 = 4;
  // RSA public key marshaled in PKIX PEM form.
  // RSA keys must have at least 2048 bits.
  ENCRYPTED_FILE_RECIPIENT_TYPE_RSA = 5;
}

message EncryptedFileRecipient {
  // Recipient public key type.
  // * age_x25519
  // * ssh_ed25519 
  // * ssh_rsa
  // * ed25519
  // * rsa
  string recipient_type = 1 [(gogoproto.jsontag) = "recipient_type"];
  // Public key marshaled according to recipient_type.
  string public_key = 2 [(gogoproto.jsontag) = "public_key"];
}
```

### Key Generation

Admins are free to configure their own public key recipients provided they are
generated by a supported algorithm.

As a convenience, we will also add a new `keygen` utility to `tctl` for key
generation. By default, this will generate a new X25519 key pair to be
configured as a recipient.

### Session Recording Modes

There are four session recording modes that describe where the recordings are
captured and how they're shipped to long term storage.
- `proxy-sync`
- `proxy`
- `node-sync`
- `node`
Where the recordings are collected is largely unimportant to the encryption strategy,
but whether or not they are handled async or sync has different requirements.

In sync modes the session recording data is written immediately to long term storage
without intermediate disk writes. This means we can simply instantiate an age
encryptor at the start of the session and encrypt the recording data as it's sent
to long term storage.

In async modes the session recording data is written to intermediate `.part` files.
These files are collected until they're ready for upload and are then combined into
a single `.tar` file. In order to encrypt individual parts, we will build a special
`io.Writer` that contains a single instance of the age encryptor that can proxy
writes across multiple files. This will require maintaining a concurrency-safe
mapping of in-progress uploads to encrypted writers which incurs a bit of added
complexity. However it intentionally avoids any sort of intermediate key management
which seems a worthwhile tradeoff.

### Protocols

We record sessions for multiple protocols, including ssh, k8s, database sessions and
more. Because this approach encrypts at the point of writing without modifying the
recording structure, the strategy for encryption is expected to be the same across
all protocols.

### Decryption and Replay

Replay of encrypted session recordings will happen through `tsh play`. It should be
possible to provide the private key used for decryption through stdin or with a file
path. This would add the flags `--decryption-key-stdin` and `--decryption-key-path`
respectively. The auth service will detect if a recording should be decrypted with an
HSM wrapped key and attempt to decrypt while streaming. If the wrapped key can not be
recovered, the auth service will still attempt to stream the encrypted recording
excluding the wrapped decryption key. This is in support of cases where another valid
private key is provided using `--decryption-key-stdin`  or `--decryption-key-path`.

Replay of encrypted recordings in the web UI will only be possible when integrating
with an HSM.

### HSMs

In order to provide seemless integration with HSMs, the auth service will allow
configuration of HSMs.

#### HSM Wrapped Data Key

In order to facilitate encryption utilizing an HSM, the auth service will generate a
per-session X25519 pair. The public key will be added to the configured list of
recipients (if any) and the private key will be wrapped by the HSM before prepending
it to the final `.tar` file of the recording. When replaying an encrypted session,
the auth service will unwrap the included private key using the HSM in order to
decrypt the recording data as it's returned to the client. This method allows the HSM
to manage the secret key material without requiring it to decrypt potentially large
session recordings. The HSM is also free to determine the key algorithm for wrapping
without being constrained to the algorithms supported by `age`.

#### HSM Configuration

HSM integration is configured either through the
`auth_service.session_recording_recipients` block in the file configuration or through
the `spec.hsm` block in a `session_recording_config` resource. Both share identical
schemas and are shown in [Config Changes](#config-changes).

Setting `enabled: true` enables HSM encrypted session recording whether or not there
are recipients configured. The default PKCS#11 configuration directory for the host
will be used by default.

The `pkcs11_config_dir` points to an explicit PKCS#11 configuration directory. It is
expected to contain a `pkcs11.conf` file and a `modules/` directory containing
module specific configurations, such as the PKCS#11 library for AWS KMS CloudHSM
Client SDK.

### Key Rotation

Key rotation is possible for new recordings by adding a new recipient entry to
the `session_recording_recipients`. Because recordings captured can be retrieved
using identities associated with any recipient used during encryption, it is possible
to verify that new recordings are still retrievable before removing the rotated
recipient. Reencrypting recordings captured before the rotation is not in scope for
this implementation. A potential method for ensuring continued access to historical
recordings would be to generate both a short term and long term recipient. The short
term recipient would be used for typical decryption operations and playback but
would be subject to rotations. The long term recipient should only ever be used in
recovery cases where a session's short term recipients have been rotated.

Any key rotation requirements for HSM wrapping keys is out of scope for this
document.

### Security

The approach described avoids any secret key management or transport within Teleport
managed infrastructure. All interactions with private keys, either manually provided
or through integration with an HSM, happen through the client tools `tctl` and
`tsh`. This should remove most concerns around proper handling of secret keys outside
of ensuring that `tctl` and `tsh` does not output or transmit any secret keys they
have access to.

One of the primary concerns outside of key management is ensuring that session
recording data is always encrypted before landing on disk or in long term storage. In
order to help enforce this, all session recording interactions should be gated behind
a standard interface that can be implemented as either plaintext or encrypted. This
will help ensure that once the encrypted writer has been selected, any interactions
with session recordings are encrypted by default.

## UX Examples
### Teleport admin generating an X25519 key pair
```bash
tctl keygen
private:
AGE-SECRET-KEY-1L0QNJCXNE546SM9AZYUDX2TQP90GJETG8AKYC8Q9J235K44TRX5SNEJW9K
public:
age18l5tzttm32yqvh9pw3dlwp8h4qlvqnx8a40hf7svyag8hnumlsus43gc0y
```

### Teleport admin wants generating a recipient for a PKCS#11 HSM wrapped key
```bash
tctl keygen --hsm-pin=12345
public:
age18l5tzttm32yqvh9pw3dlwp8h4qlvqnx8a40hf7svyag8hnumlsus43gc0yYWdlLWVuY3J5cHRpb24ub3JnL3YxCi0+IFgyNTUxOSA3V0YyR3laWFNXcHFTMXEz
```

### Teleport admin wants generating a recipient for an AWS CloudHSM wrapped key
```bash
# example for x86_64 Ubuntu 24.04 LTS

# download and install PKCS#11 library for AWS KMS CloudHSM Client Library
wget https://s3.amazonaws.com/cloudhsmv2-software/CloudHsmClient/Noble/cloudhsm-pkcs11_latest_u24.04_amd64.deb
sudo apt install ./cloudhsm-pkcs11_latest_u24.04_amd64.deb
sudo /opt/cloudhsm/bin/configure-pkcs11 -a <HSM IP addresses>

tctl keygen --hsm-pin=12345
public:
age18l5tzttm32yqvh9pw3dlwp8h4qlvqnx8a40hf7svyag8hnumlsus43gc0yYWdlLWVuY3J5cHRpb24ub3JnL3YxCi0+IFgyNTUxOSA3V0YyR3laWFNXcHFTMXEz
```

### Teleport admin wants to replay with multiple private keys
```yaml
# teleport.yaml
auth_service:
  session_recording_recipients:
  - recipient_type: age_x25519
    public_key: age18l5tzttm32yqvh9pw3dlwp8h4qlvqnx8a40hf7svyag8hnumlsus43gc0y
  - recipient_type: ssh_ed25519
    public_key: ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAdHXsIFUdyPPNrOQjhuB5SCmGfxSoMSXVZnarhzXL+I erik@Eriks-MacBook-Pro.local
```

### Teleport admin replaying encrypted session with a given private key
```bash
cat ~/my-key | tsh play --decryption-key-stdin 49608fad-7fe3-44a7-b3b5-fab0e0bd34d1
```
```bash
tsh play --decryption-key-path=~/my-key 49608fad-7fe3-44a7-b3b5-fab0e0bd34d1
```

### Teleport admin replaying an encrypted session recording containing an AWS CloudHSM wrapped key
```bash
tsh play --hsm-pin=12345 cead9efc-f0d0-4ff3-ad34-1346adc673e8
```

### Test Plan
- Sessions can be recorded when there are recipients configured
- Encrypted sessions can be played back by passing any recipient's identity to `tsh play`.
- `tctl keygen --hsm-pin=12345` provides `age_x25519` public key with a wrapped private key (can be verified by comparing key length with standard `tctl keygen`)
- Sessions encrypted using an HSM wrapped key can be played back using the same `--hsm*` configuration.
- Attempting to playback encrypted sessions with a previous major version of `tsh` should log an error prompting the user to upgrade.
