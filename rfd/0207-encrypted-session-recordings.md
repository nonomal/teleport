---
authors: Alan Parra (alan.parra@goteleport.com), Erik Tate (erik.tate@goteleport.com) 
state: draft
---

# RFD 207 - Encrypted Session Recordings

## Required Approvers
* Engineering: @rosstimothy, @zmb3, @espadolini, @nklaassen
* Security: doyensec

## What

This document proposes an approach to encrypting session recording data before
writing to disk or any S3 compatible long term storage.

## Why

File recordings on a node can be easily tampered with by users with enough access.
This could even occur within the session being recorded if the host user has root
access.

## Details

This document should fulfill the following requirements:
- Ability to encrypt session recording data during intermediate disk writes and long term storage.
- Ability to provide an externally managed public key for encryption.
- At least one method of playing back encrypted session recordings.
- Ability to source key material from an HSM.
- An encryption algorithm suitable for this workload.

### Encryption Algorithm

This RFD assumes the usage of [age](https://github.com/FiloSottile/age), which was
chosen for its provenance, simplicity, and focus on strong cryptography defaults
without requiring customization. The formal spec can be found
[here](https://age-encryption.org/v1). Officially supported key algorithms are
limited to X25519 (recommended by the spec), Ed25519, and RSA. Support for other
algorithms would either have to be requested from the upstream or manually
implemented as a custom plugin.

### Config Changes

Enabling encrypted session recordings requires configuring one or more public key
recipients that will be used during encryption. All private key identities
associated with configured recipients will be able to decrypt the resulting files.
This configuration is possible either through file configuration or dynamically
though the `session_recording_config` resource.

```yaml
# teleport.yaml
version: v3
auth_service:
  session_recording_recipients:
  - recipient_type: age_x25519
    public_key: age18l5tzttm32yqvh9pw3dlwp8h4qlvqnx8a40hf7svyag8hnumlsus43gc0y
```

```yaml
# session_recording_config resource
kind: session_recording_config
version: v2
spec:
  recipients:
  - recipient_type: age_x25519
    public_key: age18l5tzttm32yqvh9pw3dlwp8h4qlvqnx8a40hf7svyag8hnumlsus43gc0y
```

### Proto Specification
```proto
message SessionRecordingConfigSpecV2 {
  // (existing fields omitted)

  // Encrypted file recipients for recorded sessions.
  // If non-empty then all session recordings are encrypted end-to-end
  // (filesystem to end storage).
  repeated EncryptedFileRecipient recipients = 3 [(gogoproto.jsontag) = "recipients"];
}

// Illustrative, in practice a string is used for config readability.
enum EncryptedFileRecipientType {
  ENCRYPTED_FILE_RECIPIENT_TYPE_UNSPECIFIED = 0;

  // Age X25519 recipient string. Either the recipient alone or concatenated with a wrapped
  // identity.
  // * https://github.com/C2SP/C2SP/blob/8991f70ddf8a11de3a68d5a081e7be27e59d87c8/age.md#the-x25519-recipient-type
  ENCRYPTED_FILE_RECIPIENT_TYPE_AGE_X25519 = 1;
  // Ed25519 public key marshaled as an ssh-ed25519 public key.
  ENCRYPTED_FILE_RECIPIENT_TYPE_SSH_ED25519 = 2;
  // RSA public key marshaled as an ssh-rsa public key.
  // RSA keys must have at least 2048 bits.
  ENCRYPTED_FILE_RECIPIENT_TYPE_SSH_RSA = 3;
  // Ed25519 public key marshaled in PKIX PEM form.
  ENCRYPTED_FILE_RECIPIENT_TYPE_ED25519 = 4;
  // RSA public key marshaled in PKIX PEM form.
  // RSA keys must have at least 2048 bits.
  ENCRYPTED_FILE_RECIPIENT_TYPE_RSA = 5;
}

message EncryptedFileRecipient {
  // Recipient public key type.
  // * age_x25519
  // * ssh_ed25519 
  // * ssh_rsa
  // * ed25519
  // * rsa
  string recipient_type = 1 [(gogoproto.jsontag) = "recipient_type"];
  // Public key marshaled according to recipient_type.
  string public_key = 2 [(gogoproto.jsontag) = "public_key"];
}
```

### Key Generation

Admins are free to configure their own public key recipients provided they are
generated by a supported algorithm.

As a convenience, we will also add a new `keygen` utility to `tsh` for key
generation. By default, this will generate a new X25519 key pair to be
configured as a recipient, and it will also provide integration with an HSM through a
set of `--hsm*` parameters. More information about this in
[HSM Configuration](#hsm-configuration).

### Session Recording Modes

There are four session recording modes that describe where the recordings are
captured and how they're shipped to long term storage.
- `proxy-sync`
- `proxy`
- `node-sync`
- `node`
Where the recordings are collected is largely unimportant to the encryption strategy,
but whether or not they are handled async or sync has different requirements.

In sync modes the session recording data is written immediately to long term storage
without intermediate disk writes. This means we can simply instantiate an age
encryptor at the start of the session and encrypt the recording data as it's sent
to long term storage.

In async modes the session recording data is written to intermediate `.part` files.
These files are collected until they're ready for upload and are then combined into
a single `.tar` file. In order to encrypt individual parts, we will build a special
`io.Writer` that contains a single instance of the age encryptor that can proxy
writes across multiple files. This will require maintaining a concurrency-safe
mapping of in-progress uploads to encrypted writers which incurs a bit of added
complexity. However it intentionally avoids any sort of intermediate key management
which seems a worthwhile tradeoff.

### Protocols

We record sessions for multiple protocols, including ssh, k8s, database sessions and
more. Because this approach encrypts at the point of writing without modifying the
recording structure, the strategy for encryption is expected to be the same across
all protocols.

### Decryption and Replay

Replay of encrypted session recordings will happen through `tsh play`. For
convenience, it should be possible to provide the identity used for decryption
through stdin or with a file path. This would add the flags `--identity-stdin` and
`--identity-path` respectively. When playing recordings managed by an HSM, the
identity will be wrapped and included as the first line of the recording which will
be unwrapped using the same `--hsm` parameters as `tsh keygen`.

### HSMs

The implementation described should be sufficient for integrating HSMs where
human-in-the-loop is possible. Where human-in-the-loop is not possible, such as
private keys that can not be exported after creation, we will need a more direct
integration with the HSM. Teleport already integrates with PKCS#11, AWS KMS, and GCP
KMS as keystore implementations. It should be possible to leverage these integrations
to call necessary functions within supported HSMs.

#### HSM Wrapped Data Key

In order to facilitate encryption with the HSM, we will use the
`tsh keygen --hsm=<provider>` utility to generate an X25519 key pair much like the
standard flow. The utility would then integrate with the HSM's key wrapping
functionality to wrap the private key and combine it with the public key output such
as:
`<known-length-age-public-key><base64-hsm-wrapped-age-private-key>`
The combined output could then be configured as a recipient just like an ordinary
`age_x25519` public key. This method would require a small modification to the final
`.tar` file to include the wrapped key such that `tsh play` would be able to find it
and call the HSM in order to unwrap the private identity for decryption. This method
allows the HSM to manage the secret key material without requiring it to decrypt
potentially large session recordings. The HSM is also free to determine the key
algorithm for wrapping without being constrained to what is supported by `age`.

#### HSM Configuration

HSM configuration is controlled through a set of CLI parameters.

The `--hsm` parameter determines which provider should be used. Possible values are
`aws`, `gcp`, and `pkcs11`.

The `--hsm-config` parameter points to a configuration file for the relevant
provider. Typical defaults for each provider will be used if this parameter is not
explicitly defined.

The `--hsm-pin` parameter is specific to the `pkcs11` provider and defines the pin
value that should be used to authentice with the configured HSM.

### Key Rotation

Key rotation is possible for new recordings by adding a new recipient entry to
the `session_recording_recipients`. Because recordings captured can be retrieved
using identities associated with any recipient used during encryption, it is possible
to verify that new recordings are still retrievable before removing the rotated
recipient. Reencrypting recordings captured before the rotation is not in scope for
this implementation. A potential method for ensuring continued access to historical
recordings would be to generate both a short term and long term recipient. The short
term recipient would be used for typical decryption operations and playback but
would be subject to rotations. The long term recipient should only ever be used in
recovery cases where a session's short term recipients have been rotated.

### Security

The approach described avoids any secret key management or transport within Teleport
managed infrastructure. All interactions with private keys, either manually provided
or through integration with an HSM, happen through the client tool `tsh`. This should
remove most concerns around proper handling of secret keys outside of ensuring that
`tsh` does not output or transmit any secret keys it has access to.

One of the primary concerns outside of key management is ensuring that session
recording data is always encrypted before landing on disk or in long term storage. In
order to help enforce this, all session recording interactions should be gated behind
a standard interface that can be implemented as either plaintext or encrypted. This
will help ensure that once the encrypted writer has been selected, any interactions
with session recordings are encrypted by default.

## UX Examples
### Teleport admin generating an X25519 key pair
```bash
tsh keygen
private:
AGE-SECRET-KEY-1L0QNJCXNE546SM9AZYUDX2TQP90GJETG8AKYC8Q9J235K44TRX5SNEJW9K
public:
age18l5tzttm32yqvh9pw3dlwp8h4qlvqnx8a40hf7svyag8hnumlsus43gc0y
```

### Teleport admin wants generating a recipient for an AWS CloudHSM wrapped key
```bash
tsh keygen --hsm=aws
public:
age18l5tzttm32yqvh9pw3dlwp8h4qlvqnx8a40hf7svyag8hnumlsus43gc0yYWdlLWVuY3J5cHRpb24ub3JnL3YxCi0+IFgyNTUxOSA3V0YyR3laWFNXcHFTMXEz
```

### Teleport admin wants generating a recipient for a PKCS#11 HSM wrapped key
```bash
tsh keygen --hsm=pkcs11 --hsm-pin=12345
public:
age18l5tzttm32yqvh9pw3dlwp8h4qlvqnx8a40hf7svyag8hnumlsus43gc0yYWdlLWVuY3J5cHRpb24ub3JnL3YxCi0+IFgyNTUxOSA3V0YyR3laWFNXcHFTMXEz
```

### Teleport admin wants to replay with multiple private keys
```yaml
# teleport.yaml
auth_service:
  session_recording_recipients:
  - recipient_type: age_x25519
    public_key: age18l5tzttm32yqvh9pw3dlwp8h4qlvqnx8a40hf7svyag8hnumlsus43gc0y
  - recipient_type: ssh_ed25519
    public_key: ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAdHXsIFUdyPPNrOQjhuB5SCmGfxSoMSXVZnarhzXL+I erik@Eriks-MacBook-Pro.local
```

### Teleport admin replaying encrypted session with a given private key
```bash
cat ~/my-key | tsh play --identity-stdin 49608fad-7fe3-44a7-b3b5-fab0e0bd34d1
```
```bash
tsh play --identity-path=~/my-key 49608fad-7fe3-44a7-b3b5-fab0e0bd34d1
```

### Teleport admin replaying an encrypted session recording containing an AWS CloudHSM wrapped key
```bash
tsh play --hsm=aws cead9efc-f0d0-4ff3-ad34-1346adc673e8
```

### Test Plan
- Sessions can be recorded when there are recipients configured
- Encrypted sessions can be played back by passing any recipient's identity to `tsh play`.
- `tsh keygen --hsm=aws` provides `age_x25519` public key with a wrapped private key (can be verified by comparing key length with standard `tsh keygen`)
- Sessions encrypted using an HSM wrapped key can be played back using the same `--hsm` configuration.
